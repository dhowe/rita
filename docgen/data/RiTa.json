{
  "class": "rita.RiTa",
  "fields": [
    {
      "name": "VERSION",
      "example": "versionNumber = RiTa.VERSION; ",
      "variable": true,
      "description": "the current RiTa version ",
      "syntax": "RiTa.VERSION",
      "parameters": [],
      "returns": [
        {
          "type": "String",
          "desc": ""
        }
      ]
    }
  ],
  "statics": [
    {
      "name": "grammar",
      "example": "rg = RiTa.grammar();<br>rg.addRule(\"start\", \"( cat | dog | fish )\");<br>let result = rg.expand();",
      "description": "Creates a new RiTa.Grammar object -- a probabilistic context-free grammar for text-generation. You may use any of the <a href=\"../../riscript.html\">RiScript</a> features in a RiTa grammar, including transforms, sequences, and assignments.<br><pre class=\"margin\">rg = new Grammar(theRules);<br>result = rg.expand();</pre><br>RiTa grammars are valid <a href=\"https://json.org/\" target=\"new\">JSON</a> formatted strings (or JS objects or Java Maps), as follows<pre class=\"margin\">{<br>  \"start\": ( $rule1 | $rule2 | $rule3 ),<br><br>  \"rule2\": ( terminal1 | terminal2 | $rule1 ),<br><br>   ...<br>}</pre><br> If you're working in JavaScript, you can alternatively just pass a JavaScript object instead. If you're not sure whether your grammar is valid JSON, check it at <a target=\"new\" href='https://jsonlint.com/'> jsonlint.com</a>.<br><br>Note: a Grammar object will assign (by default) equal weights to all choices in a rule. You can adjust the weights by adding 'multipliers' as described in the <a href=\"../../riscript.html\">RiScript</a> reference. For example, in the rule below 'terminal1' will be chosen twice as often as the two other choices.<p><pre class=\"margin\">rule2: ( terminal1 [2] | terminal2 | $rule1 )</pre><br>",
      "syntax": "// Initialize an empty Grammar object<br><br>rg = RiTa.grammar();<br><br><br>// Or specify a grammar in a JSON string (or JS object)<br><br>rg = RiTa.grammar(myJson);<br><br><br>// Or supply a context<br><br>rg = RiTa.grammar(myJson, context);",
      "parameters": [
        {
          "type": "Object",
          "desc": "A JSON string, a JS object, or a Java Map"
        },
        {
          "type": "Object",
          "desc": "A context object (or Map in Java)"
        }
      ],
      "returns": [
        {
          "type": "Grammar",
          "desc": "a Grammar object"
        }
      ]
    },
    {
      "name": "markov",
      "example": "txt = \"This is a two sentence example. This is the second one. \"<br><br>rm = RiTa.markov(3);<br>rm.addText(txt);<br>sentences = rm.generate(2);<br><br>for (i = 0; i < sentences.length; i ++ ){<br>  println(sentences[i]);<br>}",
      "description": "Creates a new RiTa.Markov object with functions for text-generation, as well as a range of other probabilistic functions.<br><br>This object uses Markov chains (aka n-grams) with options to process single characters, words, sentences, or arbitrary regular expressions.<br><br>",
      "syntax": "// Constructs a Markov object and set its n-factor.<br><br>RiTa.markov(nFactor);<br><br><br>// Create an object and specify options<br><br>RiTa.markov(nFactor, options);<br><br>",
      "parameters": [
        {
          "type": "int",
          "desc": "n-factor - the length of each n-gram stored in the model"
        },
        {
          "type": "Object<br>(or Map in Java)",
          "desc": "options for creating the model (optional)<br><br>{int} options.maxAttempts:<br>max attempts before throwing an error in generation, default=99<br><br>{boolean} options.disableInputChecks:<br>if true, allow result to be present in the input, default=false<br><br>{int} options.maxLengthMatch:<br># of words allowed in result to match a sequence in the input, default=0<br><br>{boolean} options.trace:<br>if true, output debug log to console<br><br>{Function} options.tokenize[JS only]:<br>a custom tokenize function to use, default=RiTa.tokenize <br><br>{Function} options.untokenize[JS only]:<br>a custom tokenize function to use, default=RiTa.untokenize<br><br>"
        }
      ],
      "returns": [
        {
          "type": "Markov",
          "desc": "a RiTa.Markov object"
        }
      ]
    },
    {
      "name": "isAbbreviation",
      "example": "RiTa.isAbbreviation(\"Prof.\"); // returns -> true",
      "description": "Returns true if 'input' is an abbreviation",
      "syntax": "RiTa.isAbbreviation(input);<br/>RiTa.isAbbreviation(input, option);",
      "parameters": [
        {
          "type": "String",
          "desc": "text input"
        },
        {
          "type": "Object<br>(or Map in Java)",
          "desc": "the relevant option (optional)<br><br>{boolean} caseSensitive"
        }
      ],
      "returns": [
        {
          "type": "boolean",
          "desc": "true if 'input' is an abbreviation"
        }
      ]
    },
    {
      "name": "isQuestion",
      "example": "RiTa.isQuestion(\"what is this\"); // returns -> true",
      "description": "Returns true if sentence starts with a question word",
      "syntax": "RiTa.isQuestion(sentence);",
      "parameters": [
        {
          "type": "String",
          "desc": "sentence"
        }
      ],
      "returns": [
        {
          "type": "boolean",
          "desc": "true if 'sentence' starts with a question word"
        }
      ]
    },
    {
      "name": "isPunctuation",
      "example": "isPunctuation(\"?\"); // returns -> true",
      "description": "Returns true if every character of 'text' is a punctuation character",
      "syntax": "RiTa.isPunctuation(text);",
      "parameters": [
        {
          "type": "String",
          "desc": "text input"
        }
      ],
      "returns": [
        {
          "type": "boolean",
          "desc": "true or false"
        }
      ]
    },
    {
      "name": "analyze",
      "example": "result = RiTa.analyze(theText);",
      "description": "Computes a set of features for the object, including phonemes, syllables, stresses, and part-of-speech",
      "syntax": "RiTa.analyze(string);<br>RiTa.analyze(string, options);",
      "parameters": [
        {
          "type": "String",
          "desc": "the text to analyze"
        },
        {
          "type": "Object<br>(or Map in Java)",
          "desc": "options (optional)<br><br>{boolean} options.simple:<br> use simple tags or not, default=false<br><br>{boolean} options.silent:<br> silent LTS or not (only in JavaScript, default=false)<br><br>{boolean} options.inline:<br> inline tags or not (only in JavaScript, default=false)"
        }
      ],
      "returns": [
        {
          "type": "Object<br/>(or Map in Java)",
          "desc": "keys are [ phones, stresses, syllables, pos, tokens] "
        }
      ],
      "related": "<a href=\"../phones/\">RiTa.phones()</a>, <a href=\"../pos/\">RiTa.pos()</a>",
      "note": ""
    },
    {
      "name": "randomSeed",
      "example": "seed = 345345;<br/>RiTa.randomSeed(seed);",
      "description": "Sets the seed for RiTa's random number generator",
      "syntax": "RiTa.randomSeed(num);",
      "parameters": [
        {
          "type": "int",
          "desc": "numElements"
        }
      ],
      "returns": [],
      "related": "<a href='../randomWord'>RiTa.randomWord()</a>, <a href='../randomOrdering'>RiTa.randomOrdering()</a>"
    },
    {
      "name": "randomOrdering",
      "example": "array = RiTa.randomOrdering(5);",
      "description": "Returns a randomly ordered array of unique integers from 0 to the argument supplied.<br>The JavaScript version also accepts an array to be re-ordered as the sole parameter",
      "syntax": "RiTa.randomOrdering(numElements);<br>RiTa.randomOrdering(array); // JS only",
      "parameters": [
        {
          "type": "int",
          "desc": "numElements"
        }
      ],
      "returns": [
        {
          "type": "int[]",
          "desc": "unique integers from 0 to numElements-1 <br>(or the reordered array when supplied as a parameter)"
        }
      ]
    },
    {
      "name": "sentences",
      "example": "RiTa.sentences(\"The boy went fishing.\", he said. Then he went away.\");",
      "description": "Splits 'text' into sentences (according to Penn Treebank conventions)",
      "syntax": "RiTa.sentences(text);<br/>RiTa.sentences(text, regex);",
      "parameters": [
        {
          "type": "String",
          "desc": "the text to be split"
        },
        {
          "type": "String or Regex (JS), String or java.util.regex.Pattern (Java)",
          "desc": "regex (optional) the pattern to be used for word tokenization"
        }
      ],
      "returns": [
        {
          "type": "String[]",
          "desc": "an array of sentences"
        }
      ]
    },
    {
      "name": "addTransform",
      "example": "RiTa.addTransform(\"uc\", (s) => s.toUpperCase());<br/>RiTa.evaluate(\"This.uc() is an acronym.\");",
      "description": "Registers a new <a href=\"../../riscript.html\">RiScript</a> transform function that may then be used in all RiScript evaluations (including within Grammars)",
      "syntax": "RiTa.addTransform(name, function);",
      "parameters": [
        {
          "type": "String",
          "desc": "the input"
        },
        {
          "type": "Function",
          "desc": "the function to call, which should accept and return a string"
        }
      ],
      "returns": [],
      "related": "See <a href=\"../../riscript.html\">RiScript documentation</a> "
    },
    {
      "name": "evaluate",
      "example": "RiTa.evaluate(\"He was (happy | sad | indifferent)\");<br/>RiTa.evaluate(\"He was (happy | sad | \\$emo)\", context);",
      "description": "Parses and executes a <a href=\"../../riscript.html\">RiScript</a> string",
      "syntax": "RiTa.evaluate(string);<br/>RiTa.evaluate(string, context);",
      "parameters": [
        {
          "type": "String",
          "desc": "the input"
        },
        {
          "type": "Object<br>(or Map in Java)",
          "desc": "the context for any referenced variables or functions (optional)"
        }
      ],
      "returns": [
        {
          "type": "String",
          "desc": "the result of the evaluation"
        }
      ],
      "related": "See <a href=\"../../riscript.html\">RiScript documentation</a>"
    },
    {
      "name": "tokenize",
      "example": "<br/>sentence = \"The doctors treated dogs.\";<br/>words = RiTa.tokenize(sentence);<br/>arrayOfWords = RiTa.tokenize(sentence, \"\\\\\\\\s\");<br/><br/>",
      "description": "Tokenizes a string (into words) according to the Penn Treebank conventions.<br/>",
      "syntax": "RiTa.tokenize(text);<br/>RiTa.tokenize(text, regex);",
      "parameters": [
        {
          "type": "String",
          "desc": "the input"
        },
        {
          "type": "String OR Regex <br/>(in JS)",
          "desc": "regex (optional) the pattern to be used for tokenization"
        }
      ],
      "returns": [
        {
          "type": "String[]",
          "desc": "in which each element is a single token (or word)"
        }
      ],
      "related": "<a href='../untokenize'>RiTa.untokenize()</a>"
    },
    {
      "name": "untokenize",
      "example": "<br/>  words = [ \"The\", \"doctors\", \"treated\", \"dogs\", \".\" ];<br/>  sentence = RiTa.untokenize(words);<br/><br/>",
      "description": "Joins an array (of words and punctuation) into a sentence, according to the Penn Treebank conventions. The inverse of RiTa.tokenize().<br/>",
      "syntax": "  RiTa.untokenize(arrayOfWords);<br/>  RiTa.untokenize(arrayOfWords, delimiter);",
      "parameters": [
        {
          "type": "String[]",
          "desc": "the input, an array of words (tokens) and punctuation"
        },
        {
          "type": "String",
          "desc": "delimiter to use (optional, default=\" \" [a space])"
        }
      ],
      "returns": [
        {
          "type": "String",
          "desc": "containing all elements as a sentence"
        }
      ],
      "related": "<a href='../tokenize'>RiTa.tokenize()</a>"
    },
    {
      "name": "phones",
      "example": "<br/>RiTa.phones(\"apple\"); // returns -> ae-p-ah-l <br/><br/>RiTa.phones(\"two apples\"); // returns -> t-uw ae-p-ah-l-z <br/><br/>",
      "description": "Returns a string containing all <a target=_new href='../../phones.html'>Penn phonemes</a> for the input text",
      "syntax": "RiTa.phones(wordStr);<br>RiTa.phones(wordStr, options);",
      "parameters": [
        {
          "type": "String",
          "desc": "text to analyze"
        }
      ],
      "returns": [
        {
          "type": "String",
          "desc": "e.g., 'ae-n  eh-l-ax-f-ax-n-t  ih-z  ey  m-ae-m-ax-l'<br/>(for 'An elephant is a mammal')"
        }
      ],
      "related": "<a href=\"../analyze/\">RiTa.analyze()</a>",
      "note": ""
    },
    {
      "name": "pos",
      "example": "<br/>RiTa.pos(\"I am a cat.\"); <br/>// returns -> [ \"prp\", \"vbp\", \"dt\", \"nn\", \".\" ]<br/><br/>",
      "description": "Uses the default PosTagger to tag the input with tags from the <a href='../../postags.html'>Penn tag set</a> or the simplified tag set [a, r, v, n]",
      "syntax": "RiTa.pos(word);<br/>RiTa.pos(word, boolean);<br>RiTa.pos(word, options);",
      "parameters": [
        {
          "type": "String",
          "desc": "the text to be tagged"
        },
        {
          "type": "boolean",
          "desc": "if true, use simple tags (optional, default=false)"
        },
        {
          "type": "Object<br>(or Map in Java)",
          "desc": "optional way to set the option<br><br>{boolean} option.simple:<br>use simple tags or not"
        }
      ],
      "returns": [
        {
          "type": "String[]",
          "desc": "Array of part-of-speech tags"
        }
      ],
      "related": "<a href=\"../analyze/\">RiTa.analyze()</a>",
      "note": ""
    },
    {
      "name": "posInline",
      "example": "<br/>sentence = \"The doctors treated dogs\";<br/>pos = RiTa.posInline(sentence);<br/><br/>tokenArray = RiTa.tokenize(sentence);<br/>pos = RiTa.posInline(tokenArray);<br/><br/>",
      "description": "Takes an string returns a combined string of the form:<p><pre>'The/dt doctor/nn treated/vbd dogs/nns'</pre> using lowercased tags from the <a href='../../postags.html'>Penn tag set</a>",
      "syntax": "RiTa.posInline(word);<br>RiTa.posInline(word, simpleTags);<br>RiTa.posInline(word, option);",
      "parameters": [
        {
          "type": "String or String[]",
          "desc": "the text(or text array) to tag"
        },
        {
          "type": "boolean",
          "desc": "use tags or not (optional, default=false)"
        },
        {
          "type": "Object<br>(or Map in Java)",
          "desc": "optional way to set the option<br><br>{boolean} option.simple:<br>use simple tags or not, default=false"
        }
      ],
      "returns": [
        {
          "type": "String",
          "desc": "a combined string of words and pos tags"
        }
      ]
    },
    {
      "name": "stresses",
      "example": "RiTa.stresses(\"apple\"); // returns -> 1/0",
      "description": "Analyzes the input and returns a new string containing the stresses for each syllable of the input text ",
      "syntax": "RiTa.stresses(word);",
      "parameters": [
        {
          "type": "String",
          "desc": "text to analyze"
        }
      ],
      "returns": [
        {
          "type": "String",
          "desc": "e.g., '1/0/1', with 1's meaning 'stressed', and 0's meaning 'unstressed', "
        }
      ]
    },
    {
      "name": "syllables",
      "example": "RiTa.syllables(\"apple\"); // returns -> ae/p-ah-l",
      "description": "Analyzes the input and returns a string containing the phonemes for each syllable of each word of the input text,  delimited by dashes (phonemes) and spaces (words) ",
      "syntax": "RiTa.syllables(word);",
      "parameters": [
        {
          "type": "String",
          "desc": "text to analyze"
        }
      ],
      "returns": [
        {
          "type": "String",
          "desc": "e.g., 'dh-ax d-ao-g r-ae-n f-ae-s-t' for the 4 syllables of the phrase 'The dog ran fast'"
        }
      ],
      "related": "<a href=\"../analyze/\">RiTa.analyze()</a>",
      "note": ""
    },
    {
      "name": "concordance",
      "example": "<br/>// Java<br/><br/>opts = new HashMap();<br/>opts.put(\"ignoreCase\", false);<br/>opts.put(\"ignoreStopWords\", true);<br/><br/>result = RiTa.concordance(text, opts);<br/><br/><br/>// JavaScript<br/><br/>opts = {<br/> ignoreCase: false,<br/> ignoreStopWords: true<br/>};<br/><br/>result = RiTa.concordance(text, opts);<br/><br/>",
      "description": "Creates a concordance, a list of words with their frequency of occurence, from the given text and options",
      "syntax": "RiTa.concordance(text, opts);",
      "parameters": [
        {
          "type": "String",
          "desc": "the text"
        },
        {
          "type": "Object<br/>(or Map<String, Integer) in Java)",
          "desc": "options (optional) the relevant options for the KWIK model:<br/><br/>{int} options.wordCount: <br/># of words of context on either side of input word<br/><br/>{boolean} options.ignoreCase:<br/>Ignore upper/lower case in the model <br/><br/>{boolean} options.ignoreStopWords: <br/>Ignore words like 'the', 'and', 'a', 'of', etc, as specified in RiTa.STOP_WORDS<br/><br/>{boolean} options.ignorePunctuation:<br/>Ignore punctuation tokens in the model<br/><br/>{String[]} options.wordsToIgnore:<br/>A set of words (alternative stop-words, for example) to ignore.<br><br>"
        }
      ],
      "returns": [
        {
          "type": "Object<br/>(or Map in Java)",
          "desc": "the concordance"
        }
      ],
      "note": "See <a href=\"https://en.wikipedia.org/wiki/Concordance_%28publishing%29\">https://en.wikipedia.org/wiki/Concordance_%28publishing%29</a>"
    },
    {
      "name": "kwic",
      "example": "<br/>opts = {<br/> ignoreCase: false,<br/> ignoreStopWords: true<br/>};<br/><br/>RiTa.concordance(text, opts);<br>lines = RiTa.kwic(word, numWords);<br/><br/>",
      "description": "Return a list of occurrences of the key word in the Key-Word-In-Context (KWIC) model.<br><br>Note: RiTa.concordance() must called before calling kwic().<br><br>",
      "syntax": "RiTa.kwic(word);<br>RiTa.kwic(word, numWords);<br>// in Java only<br>RiTa.kwic(word, options)",
      "parameters": [
        {
          "type": "String",
          "desc": "the keyword of interest"
        },
        {
          "type": "int",
          "desc": "upper limit of words before/after the keyword (optional, default=6)"
        },
        {
          "type": "String[]",
          "desc": "options that can be set in Java<br><br>{String} options.text:<br>the text as the input of the KWIC model, you can set this option instead of calling RiTa.concordance() before RiTa.kwic(), if this option is set, it will overwrite the existing KWIC model<br><br>{String} options.words:<br>the words as the input of the KWIC model, you can set this option instead of calling RiTa.concordance() before RiTa.kwic(), if this option is set, it will overwrite the exist KWIC model<br><br>{int} options.numWords:<br>another way to set the numWords<br><br>{others} others:<br>if options.text or options.words is set, you can also set other concordance options for the model, please see <a href=\"../concordance/\">RiTa.concordance()</a> for detail"
        }
      ],
      "returns": [
        {
          "type": "String[]",
          "desc": "all the occurrences of the keyword in the model, each with no more than 'numWords' words of context on either side"
        }
      ],
      "note": "See <a href=\"https://en.wikipedia.org/wiki/Key_Word_in_Context\">KeyWordInContext</a> and <a href=\"https://en.wikipedia.org/wiki/Concordance_%28publishing%29\">Concordance</a> on Wikipedia"
    },
    {
      "name": "conjugate",
      "example": "// JavaScript<br/><br/>opts = {<br/> tense: RiTa.PRESENT,<br/> number: RiTa.SINGULAR,<br/> person: RiTa.THIRD<br/>};<br/><br/>result = RiTa.conjugate('swim', opts);<br/><br/><br/>// Java<br/><br/>opts = new HashMap();<br/>opts.put(\"tense\", RiTa.PAST);<br/>opts.put(\"number\", RiTa.PLURAL);<br/>opts.put(\"person\", RiTa.FIRST);<br/><br/>result = RiTa.conjugate(\"swim\", opts);<br/><br/>",
      "description": "Conjugates the 'verb' according to the specified options",
      "syntax": "RiTa.conjugate(verb, opts);",
      "parameters": [
        {
          "type": "String",
          "desc": "the root verb"
        },
        {
          "type": "Object",
          "desc": "object containing the relevant options (tense, number, person...) for the conjugator<br/><br/>{int} options.tense:<br>[RiTa.PAST, RiTa.PRESENT, or RiTa.FUTURE]<br/><br>{int} options.number:<br>[RiTa.SINGULAR or RiTa.PLURAL]<br/><br>{int} options.person:<br>[RiTa.FIRST, RiTa.SECOND or RiTa.THIRD]<br/><br/>{int} options.form:<br>[RiTa.INFINITIVE or RiTa.GERUND]<br><br>{boolean} options.passive<br><br>{boolean} options.progressive<br><br>{boolean} options.interrogative<br><br>{boolean} options.perfect"
        }
      ],
      "returns": [
        {
          "type": "String",
          "desc": "the conjugated verb"
        }
      ]
    },
    {
      "name": "pastParticiple",
      "example": "RiTa.pastParticiple(\"write\"); // returns -> written",
      "description": "Returns the past participle form of the verb",
      "syntax": "RiTa.pastParticiple(verb);",
      "parameters": [
        {
          "type": "String",
          "desc": "the verb"
        }
      ],
      "returns": [
        {
          "type": "String",
          "desc": "the past participle form of the verb"
        }
      ]
    },
    {
      "name": "presentParticiple",
      "example": "RiTa.presentParticiple(\"sit\"); // returns -> sitting",
      "description": "Returns the present participle form of the verb",
      "syntax": "RiTa.presentParticiple(verb);",
      "parameters": [
        {
          "type": "String",
          "desc": "the verb"
        }
      ],
      "returns": [
        {
          "type": "String",
          "desc": "the present participle form of the verb"
        }
      ]
    },
    {
      "name": "stem",
      "example": "<br/>s = RiTa.stem(\"cakes\"); // returns -> cake",
      "description": "Extracts base roots from a word according to the Pling stemming algorithm <br/>",
      "syntax": "RiTa.stem(word);",
      "parameters": [
        {
          "type": "String",
          "desc": "the word to analyze"
        }
      ],
      "returns": [
        {
          "type": "String",
          "desc": "the stemmed form of the word"
        }
      ]
    },
    {
      "name": "pluralize",
      "example": "<br/>pluralized = RiTa.pluralize(\"dog\"); // returns \"dogs\"<br/><br/>pluralized = RiTa.pluralize(\"mouse\"); // returns \"mice\"<br/><br/>",
      "description": "Pluralizes a noun according to pluralization rules",
      "syntax": "RiTa.pluralize(word);",
      "parameters": [
        {
          "type": "String",
          "desc": "the noun"
        },
        {
          "type": "Object<br>(or Map in Java)",
          "desc": "option for pluralization (optional)<br><br>{boolean} option.dbug: if true, output debug log to console"
        }
      ],
      "returns": [
        {
          "type": "String",
          "desc": "the (regular or irregular) plural form of the noun"
        }
      ]
    },
    {
      "name": "singularize",
      "example": "<br/>singular = RiTa.singularize(\"dogs\"); // returns \"dog\"<br/><br/>singular = RiTa.singularize(\"mice\"); // returns \"mouse\"<br/><br/>",
      "description": "Singularize a word according to singularization rules",
      "syntax": "RiTa.singularize(word);<br>RiTa.sigularize(word, option);",
      "parameters": [
        {
          "type": "String",
          "desc": "the noun"
        },
        {
          "type": "Object<br>(or Map in Java)",
          "desc": "option for singularization (optional)<br><br>{boolean} option.dbug: if true, output debug log to console"
        }
      ],
      "returns": [
        {
          "type": "String",
          "desc": "the singular form of the noun"
        }
      ]
    },
    {
      "name": "hasWord",
      "example": "RiTa.hasWord(\"apple\");",
      "description": "Returns true if the word exists in the lexicon (case-insensitive)",
      "syntax": "RiTa.hasWord(word);",
      "parameters": [
        {
          "type": "String",
          "desc": "word"
        }
      ],
      "returns": [
        {
          "type": "boolean",
          "desc": "true if the current lexicon includes the word, else false"
        }
      ]
    },
    {
      "name": "alliterations",
      "example": "RiTa.alliterations(\"cat\"); <br/>RiTa.alliterations(\"cat\", {limit: 10});<br/>RiTa.alliterations(\"cat\", { maxLength: 4, numSyllables: 1 });",
      "description": "Finds alliterations by comparing the phonemes of the input string to those of each word in the lexicon",
      "syntax": "RiTa.alliterations(word);<br/>RiTa.alliterations(word, opts);",
      "parameters": [
        {
          "type": "String",
          "desc": "input word"
        },
        {
          "type": "Object<br/>(or Map in Java)",
          "desc": "options (optional)<br/><br/>{int} options.minLength: <br/>minimum number of characters in target word (default=3)<br/><br/>{int} options.maxLength: <br/>maximum number of characters in target word<br/><br/>{int} options.numSyllables: <br/>target # of syllables in the word<br/><br/>{int} options.limit: <br/>maximum # of results to return<br/><br/>{String} options.pos: <br/>target part-of-speech for the word<br/>either from the <a href='../../postags.html'>Penn tag set</a> or the simplified tag set [a, r, v, n]<br/><br/>"
        }
      ],
      "returns": [
        {
          "type": "String[]",
          "desc": "array of alliterations"
        }
      ],
      "related": "<a href='../rhymes'>RiTa.rhymes()</a>,<a href='../search'>RiTa.search()</a>,<a href='../soundsLike'>RiTa.soundsLike()</a>,<a href='../spellsLike'>RiTa.spellsLike()</a>"
    },
    {
      "name": "randomWord",
      "example": "// a random word from the lexicon<br/>RiTa.randomWord();<br/><br/>// a random plural noun from the lexicon<br/>RiTa.randomWord({ targetPos: \"nns\"});<br/><br/>// a random word with 3 syllables and length 3 or 4<br/>RiTa.randomWord({ numSyllables: 3, maxLength: 4});",
      "description": "Returns a random word from the lexicon according to specified options",
      "syntax": "RiTa.randomWord()<br/>RiTa.randomWord(opts);<br>//in Java you can also do below<br>//which allow you to set options without Map<br>RiTa.randomWord(syllables);<br>RiTa.randomWord(pos);<br>RiTa.randomWord(pos, syllables);",
      "parameters": [
        {
          "type": "Object<br/>(or Map in Java)",
          "desc": "options (optional)<br/><br/>{int} options.minLength: <br/>minimum number of characters in target word (default=4)<br/><br/>{int} options.maxLength: <br/>maximum number of characters in target word<br/><br/>{int} options.numSyllables: <br/>target # of syllables in the word<br/><br/>{String} options.targetPos: <br/>target part-of-speech for the word<br/>either from the <a href='../../postags.html'>Penn tag set</a> or the simplified tag set [a, r, v, n]<br/><br/>"
        }
      ],
      "returns": [
        {
          "type": "String",
          "desc": "the random word"
        }
      ],
      "related": "<a href='../randomSeed'>RiTa.randomSeed()</a>"
    },
    {
      "name": "rhymes",
      "example": "RiTa.rhymes(\"cat\"); <br/>RiTa.rhymes(\"cat\", {limit: 10});<br/>RiTa.rhymes(\"cat\", { maxLength: 4, numSyllables: 1 });",
      "description": "Two words are considered as rhyming if their final stressed vowel and all following phonemes are identical",
      "syntax": "RiTa.rhymes(word);<br>RiTa.rhymes(word, options);",
      "parameters": [
        {
          "type": "String",
          "desc": "word"
        },
        {
          "type": "Object<br/>(or Map in Java)",
          "desc": "options (optional)<br/><br/>{int} options.minLength: <br/>minimum number of characters in target word<br/><br/>{int} options.maxLength: <br/>maximum number of characters in target word<br/><br/>{int} options.numSyllables: <br/>target # of syllables in the word<br/><br/>{int} options.limit: <br/>maximum # of results to return<br/><br/>{String} options.targetPos: <br/>target part-of-speech for the word<br/>either from the <a href='../../postags.html'>Penn tag set</a> or the simplified tag set [a, r, v, n]<br/><br/>"
        }
      ],
      "returns": [
        {
          "type": "String[]",
          "desc": "rhymes for the word, or an empty array if none are found"
        }
      ],
      "related": "<a href='../alliterations'>RiTa.alliterations()</a>,<a href='../search'>RiTa.search()</a>,<a href='../soundsLike'>RiTa.soundsLike()</a>,<a href='../spellsLike'>RiTa.spellsLike()</a>"
    },
    {
      "name": "search",
      "example": "RiTa.search();<br/>RiTa.search(\"tting\")",
      "description": "Searches for words in the lexicon that match the given criteria, either by phoneme, stress, or letters. If no regex or options are supplied, the full set of words is returned.",
      "syntax": "RiTa.search()<br/>RiTa.search(regex);<br/>RiTa.search(regex, opts);",
      "parameters": [
        {
          "type": "String",
          "desc": "regex pattern to match (optional)"
        },
        {
          "type": "Object<br/>(or Map in Java)",
          "desc": "options (optional)<br/><br/>{int} options.minLength: <br/>minimum number of characters in target word (default=3)<br/><br/>{int} options.maxLength: <br/>maximum number of characters in target word<br/><br/>{int} options.numSyllables: <br/>target # of syllables in the word<br/><br/>{int} options.limit: <br/>maximum # of results to return<br/><br>{String} options.type:<br>use \"stresses\" to indicate that the regex is for stresses match<br>use \"phones\" to indicate that the regex is for phonemes match<br><br/>{String} options.pos: <br/>target part-of-speech for the word<br/>either from the <a href='../../postags.html'>Penn tag set</a> or the simplified tag set [a, r, v, n]<br/><br/>"
        }
      ],
      "returns": [
        {
          "type": "String[]",
          "desc": "array of words matching the search criteria in the lexicon (or all words if no criteria is provided)"
        }
      ],
      "related": "<a href='../alliterations'>RiTa.alliterations()</a>,<a href='../rhymes'>RiTa.rhymes()</a>,<a href='../soundsLike'>RiTa.soundsLike()</a>,<a href='../spellsLike'>RiTa.spellsLike()</a>"
    },
    {
      "name": "isAdverb",
      "example": "RiTa.isAdverb(\"sleepily\");",
      "description": "Returns true if the word has an adverb form. That is, if any of its possible parts of speech are any variant of an adverb in the <a href='../../postags.html'>Penn tag set</a> (e.g. rb, rbr, rbs)",
      "syntax": "RiTa.isAdverb(word);",
      "parameters": [
        {
          "type": "String",
          "desc": "the word to test"
        }
      ],
      "returns": [
        {
          "type": "boolean",
          "desc": "true if the word can be used as an adverb "
        }
      ]
    },
    {
      "name": "isNoun",
      "example": "RiTa.isNoun(\"cat\");",
      "description": "Returns true if the word has a noun form. That is, if any of its possible parts of speech are any variant of a noun in the <a href='../../postags.html'>Penn tag set</a>(e.g. nn, nns, nnp, nnps)",
      "syntax": "RiTa.isNoun(word);",
      "parameters": [
        {
          "type": "String",
          "desc": "the word to test"
        }
      ],
      "returns": [
        {
          "type": "boolean",
          "desc": "true if the word can be used as a noun"
        }
      ]
    },
    {
      "name": "isVerb",
      "example": "RiTa.isVerb(\"run\");",
      "description": "Returns true for if word has a verb form. That is, if any of its possible parts of speech are any variant of a verb in the <a href='../../postags.html'>Penn tag set</a> (e.g. vb, vbg, vbd, vbp, vbz)",
      "syntax": "RiTa.isVerb(word);",
      "parameters": [
        {
          "type": "String",
          "desc": "the word to test"
        }
      ],
      "returns": [
        {
          "type": "boolean",
          "desc": "true if the word can be used as a verb"
        }
      ]
    },
    {
      "name": "isStopWord",
      "example": "RiTa.isStopWord(\"the\");",
      "description": "Returns true if the word is a 'stop word', a commonly used word that is often ignored in text processing. To use your own list, simply set RiTa.STOP_WORDS to a new array of words.<br> This API is not in Java yet",
      "syntax": "RiTa.isStopWord(word);",
      "parameters": [
        {
          "type": "String",
          "desc": "the word to test"
        }
      ],
      "returns": [
        {
          "type": "boolean",
          "desc": "true if the word is a stop word, according to RiTa.STOP_WORDS"
        }
      ],
      "platform": "JavaScript"
    },
    {
      "name": "isAdjective",
      "example": "RiTa.isAdjective(\"cold\");",
      "description": "Returns true if word has an adjective form. That is, if any of its possible parts of speech are any variant of an adjective in the <a href='../../postags.html'>Penn tag set</a> (e.g. jj, jjr, jjs)",
      "syntax": "RiTa.isAdjective(word);",
      "parameters": [
        {
          "type": "String",
          "desc": "the word to test"
        }
      ],
      "returns": [
        {
          "type": "boolean",
          "desc": "true if the word can be used as an adjective"
        }
      ]
    },
    {
      "name": "isAlliteration",
      "example": "RiTa.isAlliteration(\"cat\",\"kitchen\");",
      "description": "Returns true if the two words are alliterations (iff the first stressed consonant of the two match). Note: returns true if wordA.equals(wordB) and false if either (or both) are null.",
      "syntax": "RiTa.isAlliteration(word1, word2);<br>RiTa.isAlliteration(word1, word2, useLTS);",
      "parameters": [
        {
          "type": "String",
          "desc": "the first word"
        },
        {
          "type": "String",
          "desc": "the second word"
        },
        {
          "type": "boolean",
          "desc": "(optional) use LTS (letter to sound), default=false"
        }
      ],
      "returns": [
        {
          "type": "boolean",
          "desc": "true if the first stressed consonant of the two words match"
        }
      ]
    },
    {
      "name": "isRhyme",
      "example": "RiTa.isRhyme(\"cat\",\"mat\");",
      "description": "Returns true if the two words rhyme, that is, if their final stressed vowel phoneme and all following phonemes are identical, else false.<br/><br/>Note: returns false if word1.equals(word2) or if either (or both) are null;<br/><br/>",
      "syntax": "RiTa.isRhyme(word1, word2)<br/>RiTa.isRhyme(word1, word2, useLTS);",
      "parameters": [
        {
          "type": "String",
          "desc": "word1"
        },
        {
          "type": "String",
          "desc": "word2"
        },
        {
          "type": "boolean",
          "desc": "use letter-to-sound rules if not found in lexicon (optional, default=false)"
        }
      ],
      "returns": [
        {
          "type": "boolean",
          "desc": "true if the two words rhyme, else false."
        }
      ]
    },
    {
      "name": "soundsLike",
      "example": "RiTa.soundsLike(\"happy\");<br/>RiTa.soundsLike(\"happy\", { matchSpelling: true });<br/>RiTa.soundsLike(\"happy\", { limit: 10, minDistance: 2 });<br/>RiTa.soundsLike(\"happy\", { numSyllables: 2, minDistance: 2 });<br/>RiTa.soundsLike(\"happy\", { minWordLength:10, numSyllables:2 });",
      "description": "Compares the phonemes of the input word (using a version of the Levenstein min-edit distance algorithm) to each word in the lexicon, returning the set of closest matches.",
      "syntax": "RiTa.soundsLike(word);<br/>RiTa.soundsLike(word, opts);",
      "parameters": [
        {
          "type": "String",
          "desc": "the word to match"
        },
        {
          "type": "Object<br/>(or Map in Java)",
          "desc": "options (optional)<br/><br/>{bool} options.matchSpelling: <br/>if true will also attempt to match spelling<br/>by returning an intersection with <a href='../spellsLike'>RiTa.spellsLike</a> (default=false)<br/><br/>{int} options.minLength: <br/>minimum number of characters in target word (default=3)<br/><br/>{int} options.maxLength: <br/>maximum number of characters in target word<br/><br/>{int} options.numSyllables: <br/>target # of syllables in the word<br/><br/>{int} options.limit: <br/>maximum # of results to return<br/><br/>{String} options.targetPos: <br/>target part-of-speech for the word<br/>either from the <a href='../../postags.html'>Penn tag set</a> or the simplified tag set [a, r, v, n]<br/><br/>{int} options.minDistance: <br/>the minimum distance of words from the target word<br/>(increase to get more results)<br/><br/>"
        }
      ],
      "returns": [
        {
          "type": "String[]",
          "desc": "the matching words"
        }
      ],
      "related": "<a href='../spellsLike'>RiTa.spellsLike()</a>"
    },
    {
      "name": "spellsLike",
      "example": "RiTa.spellsLike(\"happy\");<br/>RiTa.spellsLike(\"happy\", { limit: 10 });<br/>RiTa.spellsLike(\"happy\", { limit: 10, minDistance: 2 });<br/>RiTa.spellsLike(\"happy\", { numSyllables: 2, minDistance: 2 });<br/>RiTa.spellsLike(\"happy\", { minWordLength:10, numSyllables:2 });",
      "description": "Compares the letters of the input word (using a version of the Levenstein min-edit distance algorithm) to each word in the lexicon, returning the set of closest matches.",
      "syntax": "RiTa.spellsLike(word)<br/>RiTa.spellsLike(word, opts)",
      "parameters": [
        {
          "type": "String",
          "desc": "the word to match"
        },
        {
          "type": "Object<br/>(or Map in Java)",
          "desc": "options (optional)<br/><br/>{int} options.minLength: <br/>minimum number of characters in target word (default=3)<br/><br/>{int} options.maxLength: <br/>maximum number of characters in target word<br/><br/>{int} options.numSyllables: <br/>target # of syllables in the word<br/><br/>{int} options.limit: <br/>maximum # of results to return<br/><br/>{String} options.targetPos: <br/>target part-of-speech for the word<br/>either from the <a href='../../postags.html'>Penn tag set</a> or the simplified tag set [a, r, v, n]<br/><br/>{int} options.minDistance: <br/>the minimum distance of words from the target word<br/>(increase to get more results)<br/><br/>"
        }
      ],
      "returns": [
        {
          "type": "String[]",
          "desc": "the matching words"
        }
      ],
      "related": "<a href='../soundsLike'>RiTa.soundsLike()</a>"
    }
  ]
}